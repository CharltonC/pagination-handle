{"version":3,"file":"index.js","sources":["../../src/index.ts"],"sourcesContent":["import {\n    IState, IOption,\n    IPageNavQuery,\n    IPageCtx, IPageSlice, IPageRange, IRelPage, IRelPageCtx, IRecordCtx, ISpreadCtx, TSpreadCtx,\n    ICmpAttrQuery, ICmpAttr, ICmpBtnAttr, ICmpSelectAttr, ISelectEvt, TPageList,\n    TFn\n} from './type';\n\n/**\n * Usage:\n *      const list = ['a', 'b', 'c', 'd'];\n *      const totalRecord = list.length;\n *\n *      const example = pgnHandle.getState(totalRecord, {\n *           page: 1,                       // optional starting page index\n *           increment: [100, 200, 300],    // used for <select>'s <option> (default 10 per page, i.e. [10])\n *           incrementIdx: 0,               // i.e. 100 per age\n *      });\n *\n *      const { startIdx, endIdx } = example;\n *      const listFor1stPage = list.slice(startIdx, endIdx);\n */\nclass PgnHandle {\n    //// Option\n    /**\n     * Merge the updated option with existing option (either custom or default)\n     * e.g. existingOption = this.state.sortOption\n     */\n    getOption(modOption: Partial<IOption>, existingOption?: IOption): IOption {\n        const baseOption = existingOption ? existingOption : this.getDefOption();\n        return { ...baseOption, ...modOption };\n    }\n\n    getDefOption(): IOption {\n        return {\n            page: 0,\n            increment: [10],\n            incrementIdx: 0,\n            maxSpread: 3\n        };\n    }\n\n    //// Full State\n    getState(totalRecord: number, pgnOption: Partial<IOption>): IState {\n        // Merge def. option with User's option\n        const defOption: IOption = this.getDefOption();\n        const { increment: [defIncrmVal] } = defOption;\n        const { page, increment, incrementIdx, maxSpread } = Object.assign(defOption, pgnOption);\n        let perPage: number = this.getNoPerPage(increment, incrementIdx, defIncrmVal);\n\n        // Skip if we only have 1 list item OR less than 2 pages\n        const defState: IState = this.getDefState(totalRecord, perPage);\n        if (totalRecord <= 1) return defState;\n        const totalPage: number = this.getTotalPage(totalRecord, perPage);\n        if (totalPage <= 1) return defState;\n\n        // Proceed as we have >=2 pages\n        const { curr, pageNo }: IPageCtx = this.getCurrPage(page, totalPage - 1);\n        const currSlice: IPageSlice = this.getPageSliceIdx(totalRecord, perPage, curr);\n        const { startIdx, endIdx } = currSlice;\n        const recordCtx = this.getRecordCtx(totalRecord, startIdx, endIdx);\n        const spreadCtx: ISpreadCtx = this.getSpreadCtx(pageNo, totalPage, maxSpread);\n        let relPage: IRelPage = this.getRelPage(totalPage, curr);\n        const relPageCtx: IRelPageCtx = this.getRelPageCtx({ curr, last: relPage.last }, relPage);\n        relPage = this.parseRelPage(relPage, relPageCtx);\n\n        return { curr, ...relPage, ...currSlice, pageNo, perPage, totalPage, ...recordCtx, ...spreadCtx };\n    }\n\n    getDefState(totalRecord: number, perPage: number): IState {\n        const startIdx: number = 0;\n        const recordCtx: IRecordCtx = this.getRecordCtx(totalRecord, startIdx);\n        return {\n            ...recordCtx,\n            perPage,\n            totalPage: 1,\n            startIdx,\n            pageNo: 1\n        } as IState;\n    }\n\n    //// Partial State\n    getRecordCtx(totalRecord: number, startIdx: number, endIdx?: number): IRecordCtx {\n        const hsRecord: boolean = totalRecord >= 1;\n        return {\n            startRecord: (hsRecord && Number.isInteger(startIdx)) ? startIdx + 1 : 0,\n            endRecord: (hsRecord && Number.isInteger(endIdx)) ? endIdx : totalRecord,\n            totalRecord\n        };\n    }\n\n    getNoPerPage(incrms: number[], incrmIdx: number, fallbackVal: number): number {\n        const hsIncrms: boolean = !!incrms.length;\n        if (!hsIncrms) return fallbackVal;\n\n        const incrm: number = incrms[incrmIdx];\n        const isValidIncrm: boolean = Number.isInteger(incrm) && incrm > 0;\n        const perPage: number = isValidIncrm ? incrms[incrmIdx] : fallbackVal;\n        return perPage;\n    }\n\n    parseNoPerPage(incrms: number[]): number[] {\n        return incrms.filter((incrm: number) => {\n            return Number.isInteger(incrm) && incrm > 0;\n        });\n    }\n\n    getTotalPage(lsLen: number, perPage: number): number {\n        const noOfPage: number = (lsLen > perPage) ? lsLen / perPage : 1;\n        return Math.ceil(noOfPage);\n    }\n\n    getCurrPage(page: number, lastPage: number): IPageCtx {\n        const curr: number = (page >= 0 && page <= lastPage) ? page : 0;\n        const pageNo: number = curr + 1;\n        return { curr, pageNo };\n    }\n\n    getRelPage(totalPage: number, currPage: number): IRelPage {\n        return {\n            first: 0,\n            prev: currPage - 1,\n            next: currPage + 1,\n            last: totalPage - 1\n        };\n    }\n\n    getRelPageCtx(pageRange: IPageRange, relPage: IRelPage): IRelPageCtx {\n        const relPageKeys = Object.getOwnPropertyNames(relPage) as (keyof IRelPage)[];\n        return relPageKeys.reduce((relPageCtx, type: string) => {\n            const pageQuery: IPageNavQuery = { type, target: relPage[type] };\n            relPageCtx[type] = this.canNavToPage(pageRange, pageQuery);\n            return relPageCtx;\n        }, {}) as IRelPageCtx;\n    }\n\n    parseRelPage(relPage: IRelPage, relPageCtx: IRelPageCtx): IRelPage {\n        const relPageKeys = Object.getOwnPropertyNames(relPage) as (keyof IRelPage)[];\n        relPageKeys.forEach((pageType: keyof IRelPage) => {\n            const page: number = relPage[pageType];\n            relPage[pageType] = relPageCtx[pageType] ? page : null;\n        });\n        return relPage;\n    }\n\n    getPageSliceIdx(totalRecord: number, perPage: number, page: number): IPageSlice {\n        let startIdx: number = page * perPage;     // inclusive index\n        let endIdx: number = startIdx + perPage;      // exclusive index\n        startIdx = startIdx < totalRecord ? startIdx : undefined;   // `undefined` is used as `null` cant be used as empty value in ES6\n        endIdx = endIdx < totalRecord ? endIdx : undefined;\n        return { startIdx, endIdx };\n    }\n\n    /**\n     * Get the page number for the left/right spread in relation to current page\n     * - When remain < maxSpread, show `maxSpread` no. of pages\n     * - When remain > maxSpread, show dots (either on left/right) + `maxSpread` no. of pages\n     * - when remain < 1, no spread is available\n     *\n     * @param maxSpread: max no. of pages for each side of the spread\n     */\n    getSpreadCtx(currPageNo: number, totalPage: number, maxSpread: number = 3): ISpreadCtx {\n        // 1 is added to `spreadRange` in case there is '...' for either 1st/last item\n        const spreadRange: any[] = [...Array(maxSpread + 1)];\n        const firstPage: number = 1;\n        const DOTS = '...';\n\n        const rtTotalRemain: number = totalPage - currPageNo;\n        const ltTotalRemain: number = currPageNo - firstPage;\n        const hsRtSpread: boolean = rtTotalRemain > 1 && rtTotalRemain < totalPage;\n        const hsLtSpread: boolean = ltTotalRemain > 1 && ltTotalRemain < totalPage;\n\n        const rtSpread: TSpreadCtx = hsRtSpread ?\n            spreadRange.reduce((container: TSpreadCtx, item, idx: number) => {\n                const pageNo: number = currPageNo + idx + 1;\n\n                // We exclude the 1st page or last page since its already available in the Pagination state\n                const isInRange: boolean = pageNo > 1 && pageNo < totalPage;\n\n                // Check if there is any pages between \"last\" page number in this loop and the actual last page\n                // - e.g. last page in the loop is: 8 | actual last page is: 10,\n                // so we have page 9 in between, which we can use '...' to represent\n                const hsGtOnePageTilLastPage: boolean = idx === maxSpread && (totalPage - pageNo) >= 1;\n\n                if (isInRange) container.push(hsGtOnePageTilLastPage ? DOTS : pageNo);\n                return container;\n            }, []) :\n            null;\n\n        const ltSpread: TSpreadCtx = hsLtSpread ?\n            spreadRange.reduce((container: TSpreadCtx, item, idx: number) => {\n                const pageNo: number = currPageNo - idx - 1;\n                const isInRange: boolean = pageNo > 1 && pageNo < totalPage;\n                const hsGtOnePageTilFirstPage: boolean = idx === maxSpread && (currPageNo - pageNo) >= 1;\n                if (isInRange) container.unshift(hsGtOnePageTilFirstPage ? DOTS : pageNo);\n                return container;\n            }, []) :\n            null;\n\n        return { ltSpread, rtSpread, maxSpread };\n    }\n\n    /**\n     * Forumla for calculating corresponding page index for left/right spread '...' based on the\n     * context of current page and the maxSpread (no. of pages between current and target page)\n     *\n     * e.g. maxSpread = 3\n     * ------------------------------------------------------------\n     * Current Page          | Spread/Target Page    | Spread Type\n     * No.      | Index      | No.      | Index      |\n     * ------------------------------------------------------------\n     * 1          0            4          3            Right Spread\n     * 10         9            6          5            Left Spread\n     */\n    getPageIdxForSpread(currPageIdx: number, maxSpread: number, isLtSpread: boolean): number {\n        return isLtSpread ?\n            (currPageIdx - maxSpread - 1) :\n            (currPageIdx + maxSpread + 1) ;\n    }\n\n    //// Helper Methods\n    canNavToPage({ curr, last }: IPageRange, { type, target }: IPageNavQuery): boolean {\n        if (!this.isGteZero([curr, last])) return false;\n\n        switch (type) {\n            case 'prev':\n                // we dont need `target < curr` since we already know `target = curr - 1;`\n                return target >= 0;\n            case 'next':\n                // we dont need `target > curr` since we already know `target = curr + 1;`\n                return target <= last;\n            case 'first':\n                // we dont need `target > curr` since we already know `target = 0`\n                return curr !== 0 && target < curr;\n            case 'last':\n                return target > curr;\n            case 'page':\n                // i.e. any prev or next\n                return this.isGteZero(target) && target !== curr && target <= last;\n            default:\n                return false;\n        }\n    }\n\n    isGteZero(vals: any | any[]): boolean {\n        return Array.isArray(vals) ?\n            vals.every((val: any) => (Number.isInteger(val) && val >= 0)) :\n            Number.isInteger(vals) && vals >= 0;\n    }\n\n    //// Generic UI Component Related\n    /**\n     * Create Generic Attributes that can be passed/mapped to Attributes/Inputs/Props of Static HTML or Angular/React/Vue/etc Components\n     *\n     * - Usage Example for React:\n     * const callback = (modState => this.setState({...this.state, ...modState})).bind(this);\n     * createGenericCmpProps({option, state, data, callback});\n     */\n    createGenericCmpAttr({ totalRecord, option, state, callback }: ICmpAttrQuery): ICmpAttr {\n        const { first, prev, next, last, ltSpread, rtSpread } = state;\n        const onEvt: TFn = this.getGenericCmpEvtHandler(totalRecord, option, callback);\n\n        return {\n            // Attr. for First/Prev/Next/Last as Button\n            firstBtnAttr: this.getTextBtnAttr(onEvt, ['first', first]),\n            prevBtnAttr: this.getTextBtnAttr(onEvt, ['prev', prev]),\n            nextBtnAttr: this.getTextBtnAttr(onEvt, ['next', next]),\n            lastBtnAttr: this.getTextBtnAttr(onEvt, ['last', last]),\n\n            // Attr. for Spread as Button\n            ltSpreadBtnsAttr: ltSpread ?\n                ltSpread.map((page: number) => this.getSpreadBtnAttr(onEvt, state, [page, true])) :\n                null,\n            rtSpreadBtnsAttr: rtSpread ?\n                rtSpread.map((page: number) => this.getSpreadBtnAttr(onEvt, state, [page, false])) :\n                null,\n\n            // Attr. for Page Select and Per Page Select\n            perPageSelectAttr: this.getPerPageSelectAttr(onEvt, option),\n            pageSelectAttr: this.getPageSelectAttr(onEvt, state),\n        };\n    }\n\n    getTextBtnAttr(onEvt: TFn, [title, pageIdx]: [string, number]): ICmpBtnAttr {\n        return {\n            title,\n            disabled: !Number.isInteger(pageIdx),\n            onClick: () => onEvt({\n                page: pageIdx\n            })\n        };\n    }\n\n    getSpreadBtnAttr(onEvt: TFn, state: IState, [page, isLtSpread]: [any, boolean]): ICmpBtnAttr {\n        const { curr, maxSpread } = state;\n\n        // If the page is not a number, then its likely dots '...' so page is jumped by an interval of `maxSpread`\n        // - e.g. maxSpread = 3, currPageNo = 6\n        // then the page is jumped to 2 (eqv. to page index of 3)\n        const isNum: boolean = typeof page === 'number';\n        // const pageIdx = isNum ? page - 1 : curr;\n        const targetPageIdx: number = isLtSpread ?\n            (isNum ? curr - 1 : this.getPageIdxForSpread(curr, maxSpread, true) ):\n            (isNum ? curr + 1 : this.getPageIdxForSpread(curr, maxSpread, false));\n\n        return {\n            title: isNum ? page : (isLtSpread ? 'left-spread' : 'right-spread'),\n            isSpread: !isNum,\n            onClick: () => onEvt({\n                page: targetPageIdx\n            })\n        };\n    }\n\n    getPageSelectAttr(onEvt: TFn, state: IState): ICmpSelectAttr {\n        const { pageNo, totalPage, ltSpread, rtSpread } = state;\n\n        const isLteOnePage: boolean = totalPage <= 1;\n\n        // Options (inclusive of all pages here)\n        const leftOptions: TPageList = (isLteOnePage || pageNo === 1) ?\n            [ 1 ] :\n            [ 1, ...(ltSpread ? ltSpread : []), pageNo ];\n\n        const rightOptions: TPageList = (isLteOnePage || pageNo === totalPage) ?\n            [] :\n            [ ...(rtSpread ? rtSpread : []), totalPage ];\n\n        const options: TPageList = [ ...leftOptions, ...rightOptions ];\n        const selectedOptionIdx: number = leftOptions.length - 1;\n\n        return {\n            title: 'page select',\n            disabled: isLteOnePage,\n            options,\n            selectedOptionValue: pageNo,\n            selectedOptionIdx,\n            onSelect: ({ target }: ISelectEvt) => {\n                const targetPageIdx: number = this.getTargetPageIdxByPos(\n                    state,\n                    options,\n                    [ parseInt(target.value, 10), selectedOptionIdx ]\n                );\n                onEvt({ page: targetPageIdx });\n            }\n        };\n    }\n\n    getPerPageSelectAttr(onEvt: TFn, option: IOption): ICmpSelectAttr {\n        const { increment, incrementIdx } = option;\n        return {\n            title: 'per page select',\n            disabled: increment.length <= 1,\n            options: increment,\n            selectedOptionValue: increment[incrementIdx],\n            selectedOptionIdx: incrementIdx,\n            onSelect: ({ target }: ISelectEvt) => onEvt({\n                page: 0,\n                incrementIdx: parseInt(target.value, 10)\n            })\n        };\n    }\n\n    getGenericCmpEvtHandler(totalRecord: number, option: IOption, callback?: TFn): TFn {\n        return ((modOption: Partial<IOption>): void => {\n            const pgnOption: IOption = this.getOption(modOption, option);\n            const pgnState: IState = this.getState(totalRecord, pgnOption);\n            if (callback) callback({ pgnOption, pgnState });\n        });\n    }\n\n    getTargetPageIdxByPos(state: IState, pages: TPageList, [currPos, activePos]: [number, number]): number {\n        const { curr, maxSpread } = state;\n        const page: string | number = pages[currPos];\n        const targetPageIdx: number = typeof page === 'number' ?\n            page - 1 :\n            this.getPageIdxForSpread(curr, maxSpread, currPos < activePos);\n        return targetPageIdx;\n    }\n}\n\nexport default PgnHandle;"],"names":["PgnHandle","modOption","existingOption","baseOption","getDefOption","page","increment","incrementIdx","maxSpread","totalRecord","pgnOption","defOption","defIncrmVal","Object","assign","perPage","getNoPerPage","defState","getDefState","totalPage","getTotalPage","getCurrPage","curr","pageNo","currSlice","getPageSliceIdx","startIdx","endIdx","recordCtx","getRecordCtx","spreadCtx","getSpreadCtx","relPage","getRelPage","relPageCtx","getRelPageCtx","last","parseRelPage","hsRecord","startRecord","Number","isInteger","endRecord","incrms","incrmIdx","fallbackVal","hsIncrms","length","incrm","isValidIncrm","filter","lsLen","noOfPage","Math","ceil","lastPage","currPage","first","prev","next","pageRange","relPageKeys","getOwnPropertyNames","reduce","type","pageQuery","target","canNavToPage","forEach","pageType","undefined","currPageNo","spreadRange","Array","firstPage","DOTS","rtTotalRemain","ltTotalRemain","hsRtSpread","hsLtSpread","rtSpread","container","item","idx","isInRange","hsGtOnePageTilLastPage","push","ltSpread","hsGtOnePageTilFirstPage","unshift","currPageIdx","isLtSpread","isGteZero","vals","isArray","every","val","option","state","callback","onEvt","getGenericCmpEvtHandler","firstBtnAttr","getTextBtnAttr","prevBtnAttr","nextBtnAttr","lastBtnAttr","ltSpreadBtnsAttr","map","getSpreadBtnAttr","rtSpreadBtnsAttr","perPageSelectAttr","getPerPageSelectAttr","pageSelectAttr","getPageSelectAttr","title","pageIdx","disabled","onClick","isNum","targetPageIdx","getPageIdxForSpread","isSpread","isLteOnePage","leftOptions","rightOptions","options","selectedOptionIdx","selectedOptionValue","onSelect","getTargetPageIdxByPos","parseInt","value","getOption","pgnState","getState","pages","currPos","activePos"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;;;;;;;;;;;;;;IAcMA;;;;;;;AACF;;AACA;;;;8BAIUC,WAA6BC,gBAAmC;AACtE,UAAMC,UAAU,GAAGD,cAAc,GAAGA,cAAH,GAAoB,KAAKE,YAAL,EAArD;AACA,+CAAYD,UAAZ,GAA2BF,SAA3B;AACH;;;mCAEuB;AACpB,aAAO;AACHI,QAAAA,IAAI,EAAE,CADH;AAEHC,QAAAA,SAAS,EAAE,CAAC,EAAD,CAFR;AAGHC,QAAAA,YAAY,EAAE,CAHX;AAIHC,QAAAA,SAAS,EAAE;AAJR,OAAP;AAMH;;;;6BAGQC,aAAqBC,WAAqC;AAC/D;AACA,UAAMC,SAAkB,GAAG,KAAKP,YAAL,EAA3B;;AAF+D,gDAG1BO,SAH0B,CAGvDL,SAHuD;AAAA,UAG3CM,WAH2C;;AAAA,2BAIVC,MAAM,CAACC,MAAP,CAAcH,SAAd,EAAyBD,SAAzB,CAJU;AAAA,UAIvDL,IAJuD,kBAIvDA,IAJuD;AAAA,UAIjDC,SAJiD,kBAIjDA,SAJiD;AAAA,UAItCC,YAJsC,kBAItCA,YAJsC;AAAA,UAIxBC,SAJwB,kBAIxBA,SAJwB;;AAK/D,UAAIO,OAAe,GAAG,KAAKC,YAAL,CAAkBV,SAAlB,EAA6BC,YAA7B,EAA2CK,WAA3C,CAAtB,CAL+D;;AAQ/D,UAAMK,QAAgB,GAAG,KAAKC,WAAL,CAAiBT,WAAjB,EAA8BM,OAA9B,CAAzB;AACA,UAAIN,WAAW,IAAI,CAAnB,EAAsB,OAAOQ,QAAP;AACtB,UAAME,SAAiB,GAAG,KAAKC,YAAL,CAAkBX,WAAlB,EAA+BM,OAA/B,CAA1B;AACA,UAAII,SAAS,IAAI,CAAjB,EAAoB,OAAOF,QAAP,CAX2C;;AAAA,8BAc5B,KAAKI,WAAL,CAAiBhB,IAAjB,EAAuBc,SAAS,GAAG,CAAnC,CAd4B;AAAA,UAcvDG,IAduD,qBAcvDA,IAduD;AAAA,UAcjDC,MAdiD,qBAcjDA,MAdiD;;AAe/D,UAAMC,SAAqB,GAAG,KAAKC,eAAL,CAAqBhB,WAArB,EAAkCM,OAAlC,EAA2CO,IAA3C,CAA9B;AAf+D,UAgBvDI,QAhBuD,GAgBlCF,SAhBkC,CAgBvDE,QAhBuD;AAAA,UAgB7CC,MAhB6C,GAgBlCH,SAhBkC,CAgB7CG,MAhB6C;AAiB/D,UAAMC,SAAS,GAAG,KAAKC,YAAL,CAAkBpB,WAAlB,EAA+BiB,QAA/B,EAAyCC,MAAzC,CAAlB;AACA,UAAMG,SAAqB,GAAG,KAAKC,YAAL,CAAkBR,MAAlB,EAA0BJ,SAA1B,EAAqCX,SAArC,CAA9B;AACA,UAAIwB,OAAiB,GAAG,KAAKC,UAAL,CAAgBd,SAAhB,EAA2BG,IAA3B,CAAxB;AACA,UAAMY,UAAuB,GAAG,KAAKC,aAAL,CAAmB;AAAEb,QAAAA,IAAI,EAAJA,IAAF;AAAQc,QAAAA,IAAI,EAAEJ,OAAO,CAACI;AAAtB,OAAnB,EAAiDJ,OAAjD,CAAhC;AACAA,MAAAA,OAAO,GAAG,KAAKK,YAAL,CAAkBL,OAAlB,EAA2BE,UAA3B,CAAV;AAEA;AAASZ,QAAAA,IAAI,EAAJA;AAAT,SAAkBU,OAAlB,GAA8BR,SAA9B;AAAyCD,QAAAA,MAAM,EAANA,MAAzC;AAAiDR,QAAAA,OAAO,EAAPA,OAAjD;AAA0DI,QAAAA,SAAS,EAATA;AAA1D,SAAwES,SAAxE,GAAsFE,SAAtF;AACH;;;gCAEWrB,aAAqBM,SAAyB;AACtD,UAAMW,QAAgB,GAAG,CAAzB;AACA,UAAME,SAAqB,GAAG,KAAKC,YAAL,CAAkBpB,WAAlB,EAA+BiB,QAA/B,CAA9B;AACA,+CACOE,SADP;AAEIb,QAAAA,OAAO,EAAPA,OAFJ;AAGII,QAAAA,SAAS,EAAE,CAHf;AAIIO,QAAAA,QAAQ,EAARA,QAJJ;AAKIH,QAAAA,MAAM,EAAE;AALZ;AAOH;;;;iCAGYd,aAAqBiB,UAAkBC,QAA6B;AAC7E,UAAMW,QAAiB,GAAG7B,WAAW,IAAI,CAAzC;AACA,aAAO;AACH8B,QAAAA,WAAW,EAAGD,QAAQ,IAAIE,MAAM,CAACC,SAAP,CAAiBf,QAAjB,CAAb,GAA2CA,QAAQ,GAAG,CAAtD,GAA0D,CADpE;AAEHgB,QAAAA,SAAS,EAAGJ,QAAQ,IAAIE,MAAM,CAACC,SAAP,CAAiBd,MAAjB,CAAb,GAAyCA,MAAzC,GAAkDlB,WAF1D;AAGHA,QAAAA,WAAW,EAAXA;AAHG,OAAP;AAKH;;;iCAEYkC,QAAkBC,UAAkBC,aAA6B;AAC1E,UAAMC,QAAiB,GAAG,CAAC,CAACH,MAAM,CAACI,MAAnC;AACA,UAAI,CAACD,QAAL,EAAe,OAAOD,WAAP;AAEf,UAAMG,KAAa,GAAGL,MAAM,CAACC,QAAD,CAA5B;AACA,UAAMK,YAAqB,GAAGT,MAAM,CAACC,SAAP,CAAiBO,KAAjB,KAA2BA,KAAK,GAAG,CAAjE;AACA,UAAMjC,OAAe,GAAGkC,YAAY,GAAGN,MAAM,CAACC,QAAD,CAAT,GAAsBC,WAA1D;AACA,aAAO9B,OAAP;AACH;;;mCAEc4B,QAA4B;AACvC,aAAOA,MAAM,CAACO,MAAP,CAAc,UAACF,KAAD,EAAmB;AACpC,eAAOR,MAAM,CAACC,SAAP,CAAiBO,KAAjB,KAA2BA,KAAK,GAAG,CAA1C;AACH,OAFM,CAAP;AAGH;;;iCAEYG,OAAepC,SAAyB;AACjD,UAAMqC,QAAgB,GAAID,KAAK,GAAGpC,OAAT,GAAoBoC,KAAK,GAAGpC,OAA5B,GAAsC,CAA/D;AACA,aAAOsC,IAAI,CAACC,IAAL,CAAUF,QAAV,CAAP;AACH;;;gCAEW/C,MAAckD,UAA4B;AAClD,UAAMjC,IAAY,GAAIjB,IAAI,IAAI,CAAR,IAAaA,IAAI,IAAIkD,QAAtB,GAAkClD,IAAlC,GAAyC,CAA9D;AACA,UAAMkB,MAAc,GAAGD,IAAI,GAAG,CAA9B;AACA,aAAO;AAAEA,QAAAA,IAAI,EAAJA,IAAF;AAAQC,QAAAA,MAAM,EAANA;AAAR,OAAP;AACH;;;+BAEUJ,WAAmBqC,UAA4B;AACtD,aAAO;AACHC,QAAAA,KAAK,EAAE,CADJ;AAEHC,QAAAA,IAAI,EAAEF,QAAQ,GAAG,CAFd;AAGHG,QAAAA,IAAI,EAAEH,QAAQ,GAAG,CAHd;AAIHpB,QAAAA,IAAI,EAAEjB,SAAS,GAAG;AAJf,OAAP;AAMH;;;kCAEayC,WAAuB5B,SAAgC;AAAA;;AACjE,UAAM6B,WAAW,GAAGhD,MAAM,CAACiD,mBAAP,CAA2B9B,OAA3B,CAApB;AACA,aAAO6B,WAAW,CAACE,MAAZ,CAAmB,UAAC7B,UAAD,EAAa8B,IAAb,EAA8B;AACpD,YAAMC,SAAwB,GAAG;AAAED,UAAAA,IAAI,EAAJA,IAAF;AAAQE,UAAAA,MAAM,EAAElC,OAAO,CAACgC,IAAD;AAAvB,SAAjC;AACA9B,QAAAA,UAAU,CAAC8B,IAAD,CAAV,GAAmB,KAAI,CAACG,YAAL,CAAkBP,SAAlB,EAA6BK,SAA7B,CAAnB;AACA,eAAO/B,UAAP;AACH,OAJM,EAIJ,EAJI,CAAP;AAKH;;;iCAEYF,SAAmBE,YAAmC;AAC/D,UAAM2B,WAAW,GAAGhD,MAAM,CAACiD,mBAAP,CAA2B9B,OAA3B,CAApB;AACA6B,MAAAA,WAAW,CAACO,OAAZ,CAAoB,UAACC,QAAD,EAA8B;AAC9C,YAAMhE,IAAY,GAAG2B,OAAO,CAACqC,QAAD,CAA5B;AACArC,QAAAA,OAAO,CAACqC,QAAD,CAAP,GAAoBnC,UAAU,CAACmC,QAAD,CAAV,GAAuBhE,IAAvB,GAA8B,IAAlD;AACH,OAHD;AAIA,aAAO2B,OAAP;AACH;;;oCAEevB,aAAqBM,SAAiBV,MAA0B;AAC5E,UAAIqB,QAAgB,GAAGrB,IAAI,GAAGU,OAA9B,CAD4E;;AAE5E,UAAIY,MAAc,GAAGD,QAAQ,GAAGX,OAAhC,CAF4E;;AAG5EW,MAAAA,QAAQ,GAAGA,QAAQ,GAAGjB,WAAX,GAAyBiB,QAAzB,GAAoC4C,SAA/C,CAH4E;;AAI5E3C,MAAAA,MAAM,GAAGA,MAAM,GAAGlB,WAAT,GAAuBkB,MAAvB,GAAgC2C,SAAzC;AACA,aAAO;AAAE5C,QAAAA,QAAQ,EAARA,QAAF;AAAYC,QAAAA,MAAM,EAANA;AAAZ,OAAP;AACH;AAED;;;;;;;;;;;iCAQa4C,YAAoBpD,WAAsD;AAAA,UAAnCX,SAAmC,uEAAf,CAAe;;AACnF;AACA,UAAMgE,WAAkB,sBAAOC,KAAK,CAACjE,SAAS,GAAG,CAAb,CAAZ,CAAxB;;AACA,UAAMkE,SAAiB,GAAG,CAA1B;AACA,UAAMC,IAAI,GAAG,KAAb;AAEA,UAAMC,aAAqB,GAAGzD,SAAS,GAAGoD,UAA1C;AACA,UAAMM,aAAqB,GAAGN,UAAU,GAAGG,SAA3C;AACA,UAAMI,UAAmB,GAAGF,aAAa,GAAG,CAAhB,IAAqBA,aAAa,GAAGzD,SAAjE;AACA,UAAM4D,UAAmB,GAAGF,aAAa,GAAG,CAAhB,IAAqBA,aAAa,GAAG1D,SAAjE;AAEA,UAAM6D,QAAoB,GAAGF,UAAU,GACnCN,WAAW,CAACT,MAAZ,CAAmB,UAACkB,SAAD,EAAwBC,IAAxB,EAA8BC,GAA9B,EAA8C;AAC7D,YAAM5D,MAAc,GAAGgD,UAAU,GAAGY,GAAb,GAAmB,CAA1C,CAD6D;;AAI7D,YAAMC,SAAkB,GAAG7D,MAAM,GAAG,CAAT,IAAcA,MAAM,GAAGJ,SAAlD,CAJ6D;AAO7D;AACA;;AACA,YAAMkE,sBAA+B,GAAGF,GAAG,KAAK3E,SAAR,IAAsBW,SAAS,GAAGI,MAAb,IAAwB,CAArF;AAEA,YAAI6D,SAAJ,EAAeH,SAAS,CAACK,IAAV,CAAeD,sBAAsB,GAAGV,IAAH,GAAUpD,MAA/C;AACf,eAAO0D,SAAP;AACH,OAbD,EAaG,EAbH,CADmC,GAenC,IAfJ;AAiBA,UAAMM,QAAoB,GAAGR,UAAU,GACnCP,WAAW,CAACT,MAAZ,CAAmB,UAACkB,SAAD,EAAwBC,IAAxB,EAA8BC,GAA9B,EAA8C;AAC7D,YAAM5D,MAAc,GAAGgD,UAAU,GAAGY,GAAb,GAAmB,CAA1C;AACA,YAAMC,SAAkB,GAAG7D,MAAM,GAAG,CAAT,IAAcA,MAAM,GAAGJ,SAAlD;AACA,YAAMqE,uBAAgC,GAAGL,GAAG,KAAK3E,SAAR,IAAsB+D,UAAU,GAAGhD,MAAd,IAAyB,CAAvF;AACA,YAAI6D,SAAJ,EAAeH,SAAS,CAACQ,OAAV,CAAkBD,uBAAuB,GAAGb,IAAH,GAAUpD,MAAnD;AACf,eAAO0D,SAAP;AACH,OAND,EAMG,EANH,CADmC,GAQnC,IARJ;AAUA,aAAO;AAAEM,QAAAA,QAAQ,EAARA,QAAF;AAAYP,QAAAA,QAAQ,EAARA,QAAZ;AAAsBxE,QAAAA,SAAS,EAATA;AAAtB,OAAP;AACH;AAED;;;;;;;;;;;;;;;wCAYoBkF,aAAqBlF,WAAmBmF,YAA6B;AACrF,aAAOA,UAAU,GACZD,WAAW,GAAGlF,SAAd,GAA0B,CADd,GAEZkF,WAAW,GAAGlF,SAAd,GAA0B,CAF/B;AAGH;;;;8CAGkF;AAAA,UAApEc,IAAoE,QAApEA,IAAoE;AAAA,UAA9Dc,IAA8D,QAA9DA,IAA8D;AAAA,UAAxC4B,IAAwC,SAAxCA,IAAwC;AAAA,UAAlCE,MAAkC,SAAlCA,MAAkC;AAC/E,UAAI,CAAC,KAAK0B,SAAL,CAAe,CAACtE,IAAD,EAAOc,IAAP,CAAf,CAAL,EAAmC,OAAO,KAAP;;AAEnC,cAAQ4B,IAAR;AACI,aAAK,MAAL;AACI;AACA,iBAAOE,MAAM,IAAI,CAAjB;;AACJ,aAAK,MAAL;AACI;AACA,iBAAOA,MAAM,IAAI9B,IAAjB;;AACJ,aAAK,OAAL;AACI;AACA,iBAAOd,IAAI,KAAK,CAAT,IAAc4C,MAAM,GAAG5C,IAA9B;;AACJ,aAAK,MAAL;AACI,iBAAO4C,MAAM,GAAG5C,IAAhB;;AACJ,aAAK,MAAL;AACI;AACA,iBAAO,KAAKsE,SAAL,CAAe1B,MAAf,KAA0BA,MAAM,KAAK5C,IAArC,IAA6C4C,MAAM,IAAI9B,IAA9D;;AACJ;AACI,iBAAO,KAAP;AAhBR;AAkBH;;;8BAESyD,MAA4B;AAClC,aAAOpB,KAAK,CAACqB,OAAN,CAAcD,IAAd,IACHA,IAAI,CAACE,KAAL,CAAW,UAACC,GAAD;AAAA,eAAexD,MAAM,CAACC,SAAP,CAAiBuD,GAAjB,KAAyBA,GAAG,IAAI,CAA/C;AAAA,OAAX,CADG,GAEHxD,MAAM,CAACC,SAAP,CAAiBoD,IAAjB,KAA0BA,IAAI,IAAI,CAFtC;AAGH;;AAGD;;;;;;;;;;gDAOwF;AAAA;;AAAA,UAAjEpF,WAAiE,SAAjEA,WAAiE;AAAA,UAApDwF,MAAoD,SAApDA,MAAoD;AAAA,UAA5CC,KAA4C,SAA5CA,KAA4C;AAAA,UAArCC,QAAqC,SAArCA,QAAqC;AAAA,UAC5E1C,KAD4E,GAC5ByC,KAD4B,CAC5EzC,KAD4E;AAAA,UACrEC,IADqE,GAC5BwC,KAD4B,CACrExC,IADqE;AAAA,UAC/DC,IAD+D,GAC5BuC,KAD4B,CAC/DvC,IAD+D;AAAA,UACzDvB,IADyD,GAC5B8D,KAD4B,CACzD9D,IADyD;AAAA,UACnDmD,QADmD,GAC5BW,KAD4B,CACnDX,QADmD;AAAA,UACzCP,QADyC,GAC5BkB,KAD4B,CACzClB,QADyC;AAEpF,UAAMoB,KAAU,GAAG,KAAKC,uBAAL,CAA6B5F,WAA7B,EAA0CwF,MAA1C,EAAkDE,QAAlD,CAAnB;AAEA,aAAO;AACH;AACAG,QAAAA,YAAY,EAAE,KAAKC,cAAL,CAAoBH,KAApB,EAA2B,CAAC,OAAD,EAAU3C,KAAV,CAA3B,CAFX;AAGH+C,QAAAA,WAAW,EAAE,KAAKD,cAAL,CAAoBH,KAApB,EAA2B,CAAC,MAAD,EAAS1C,IAAT,CAA3B,CAHV;AAIH+C,QAAAA,WAAW,EAAE,KAAKF,cAAL,CAAoBH,KAApB,EAA2B,CAAC,MAAD,EAASzC,IAAT,CAA3B,CAJV;AAKH+C,QAAAA,WAAW,EAAE,KAAKH,cAAL,CAAoBH,KAApB,EAA2B,CAAC,MAAD,EAAShE,IAAT,CAA3B,CALV;AAOH;AACAuE,QAAAA,gBAAgB,EAAEpB,QAAQ,GACtBA,QAAQ,CAACqB,GAAT,CAAa,UAACvG,IAAD;AAAA,iBAAkB,MAAI,CAACwG,gBAAL,CAAsBT,KAAtB,EAA6BF,KAA7B,EAAoC,CAAC7F,IAAD,EAAO,IAAP,CAApC,CAAlB;AAAA,SAAb,CADsB,GAEtB,IAVD;AAWHyG,QAAAA,gBAAgB,EAAE9B,QAAQ,GACtBA,QAAQ,CAAC4B,GAAT,CAAa,UAACvG,IAAD;AAAA,iBAAkB,MAAI,CAACwG,gBAAL,CAAsBT,KAAtB,EAA6BF,KAA7B,EAAoC,CAAC7F,IAAD,EAAO,KAAP,CAApC,CAAlB;AAAA,SAAb,CADsB,GAEtB,IAbD;AAeH;AACA0G,QAAAA,iBAAiB,EAAE,KAAKC,oBAAL,CAA0BZ,KAA1B,EAAiCH,MAAjC,CAhBhB;AAiBHgB,QAAAA,cAAc,EAAE,KAAKC,iBAAL,CAAuBd,KAAvB,EAA8BF,KAA9B;AAjBb,OAAP;AAmBH;;;mCAEcE,cAA6D;AAAA;AAAA,UAAhDe,KAAgD;AAAA,UAAzCC,OAAyC;;AACxE,aAAO;AACHD,QAAAA,KAAK,EAALA,KADG;AAEHE,QAAAA,QAAQ,EAAE,CAAC7E,MAAM,CAACC,SAAP,CAAiB2E,OAAjB,CAFR;AAGHE,QAAAA,OAAO,EAAE;AAAA,iBAAMlB,KAAK,CAAC;AACjB/F,YAAAA,IAAI,EAAE+G;AADW,WAAD,CAAX;AAAA;AAHN,OAAP;AAOH;;;qCAEgBhB,OAAYF,cAAgE;AAAA;AAAA,UAAhD7F,IAAgD;AAAA,UAA1CsF,UAA0C;;AAAA,UACjFrE,IADiF,GAC7D4E,KAD6D,CACjF5E,IADiF;AAAA,UAC3Ed,SAD2E,GAC7D0F,KAD6D,CAC3E1F,SAD2E;AAIzF;AACA;;AACA,UAAM+G,KAAc,GAAG,OAAOlH,IAAP,KAAgB,QAAvC,CANyF;;AAQzF,UAAMmH,aAAqB,GAAG7B,UAAU,GACnC4B,KAAK,GAAGjG,IAAI,GAAG,CAAV,GAAc,KAAKmG,mBAAL,CAAyBnG,IAAzB,EAA+Bd,SAA/B,EAA0C,IAA1C,CADgB,GAEnC+G,KAAK,GAAGjG,IAAI,GAAG,CAAV,GAAc,KAAKmG,mBAAL,CAAyBnG,IAAzB,EAA+Bd,SAA/B,EAA0C,KAA1C,CAFxB;AAIA,aAAO;AACH2G,QAAAA,KAAK,EAAEI,KAAK,GAAGlH,IAAH,GAAWsF,UAAU,GAAG,aAAH,GAAmB,cADjD;AAEH+B,QAAAA,QAAQ,EAAE,CAACH,KAFR;AAGHD,QAAAA,OAAO,EAAE;AAAA,iBAAMlB,KAAK,CAAC;AACjB/F,YAAAA,IAAI,EAAEmH;AADW,WAAD,CAAX;AAAA;AAHN,OAAP;AAOH;;;sCAEiBpB,OAAYF,OAA+B;AAAA;;AAAA,UACjD3E,MADiD,GACP2E,KADO,CACjD3E,MADiD;AAAA,UACzCJ,SADyC,GACP+E,KADO,CACzC/E,SADyC;AAAA,UAC9BoE,QAD8B,GACPW,KADO,CAC9BX,QAD8B;AAAA,UACpBP,QADoB,GACPkB,KADO,CACpBlB,QADoB;AAGzD,UAAM2C,YAAqB,GAAGxG,SAAS,IAAI,CAA3C,CAHyD;;AAMzD,UAAMyG,WAAsB,GAAID,YAAY,IAAIpG,MAAM,KAAK,CAA5B,GAC3B,CAAE,CAAF,CAD2B,IAEzB,CAFyB,4BAElBgE,QAAQ,GAAGA,QAAH,GAAc,EAFJ,IAEShE,MAFT,EAA/B;AAIA,UAAMsG,YAAuB,GAAIF,YAAY,IAAIpG,MAAM,KAAKJ,SAA5B,GAC5B,EAD4B,gCAEtB6D,QAAQ,GAAGA,QAAH,GAAc,EAFA,IAEK7D,SAFL,EAAhC;AAIA,UAAM2G,OAAkB,gCAAQF,WAAR,sBAAwBC,YAAxB,EAAxB;AACA,UAAME,iBAAyB,GAAGH,WAAW,CAAC7E,MAAZ,GAAqB,CAAvD;AAEA,aAAO;AACHoE,QAAAA,KAAK,EAAE,aADJ;AAEHE,QAAAA,QAAQ,EAAEM,YAFP;AAGHG,QAAAA,OAAO,EAAPA,OAHG;AAIHE,QAAAA,mBAAmB,EAAEzG,MAJlB;AAKHwG,QAAAA,iBAAiB,EAAjBA,iBALG;AAMHE,QAAAA,QAAQ,EAAE,yBAA4B;AAAA,cAAzB/D,MAAyB,SAAzBA,MAAyB;;AAClC,cAAMsD,aAAqB,GAAG,MAAI,CAACU,qBAAL,CAC1BhC,KAD0B,EAE1B4B,OAF0B,EAG1B,CAAEK,QAAQ,CAACjE,MAAM,CAACkE,KAAR,EAAe,EAAf,CAAV,EAA8BL,iBAA9B,CAH0B,CAA9B;;AAKA3B,UAAAA,KAAK,CAAC;AAAE/F,YAAAA,IAAI,EAAEmH;AAAR,WAAD,CAAL;AACH;AAbE,OAAP;AAeH;;;yCAEoBpB,OAAYH,QAAiC;AAAA,UACtD3F,SADsD,GAC1B2F,MAD0B,CACtD3F,SADsD;AAAA,UAC3CC,YAD2C,GAC1B0F,MAD0B,CAC3C1F,YAD2C;AAE9D,aAAO;AACH4G,QAAAA,KAAK,EAAE,iBADJ;AAEHE,QAAAA,QAAQ,EAAE/G,SAAS,CAACyC,MAAV,IAAoB,CAF3B;AAGH+E,QAAAA,OAAO,EAAExH,SAHN;AAIH0H,QAAAA,mBAAmB,EAAE1H,SAAS,CAACC,YAAD,CAJ3B;AAKHwH,QAAAA,iBAAiB,EAAExH,YALhB;AAMH0H,QAAAA,QAAQ,EAAE;AAAA,cAAG/D,MAAH,SAAGA,MAAH;AAAA,iBAA4BkC,KAAK,CAAC;AACxC/F,YAAAA,IAAI,EAAE,CADkC;AAExCE,YAAAA,YAAY,EAAE4H,QAAQ,CAACjE,MAAM,CAACkE,KAAR,EAAe,EAAf;AAFkB,WAAD,CAAjC;AAAA;AANP,OAAP;AAWH;;;4CAEuB3H,aAAqBwF,QAAiBE,UAAqB;AAAA;;AAC/E,aAAQ,UAAClG,SAAD,EAAuC;AAC3C,YAAMS,SAAkB,GAAG,MAAI,CAAC2H,SAAL,CAAepI,SAAf,EAA0BgG,MAA1B,CAA3B;;AACA,YAAMqC,QAAgB,GAAG,MAAI,CAACC,QAAL,CAAc9H,WAAd,EAA2BC,SAA3B,CAAzB;;AACA,YAAIyF,QAAJ,EAAcA,QAAQ,CAAC;AAAEzF,UAAAA,SAAS,EAATA,SAAF;AAAa4H,UAAAA,QAAQ,EAARA;AAAb,SAAD,CAAR;AACjB,OAJD;AAKH;;;0CAEqBpC,OAAesC,eAAkE;AAAA;AAAA,UAA/CC,OAA+C;AAAA,UAAtCC,SAAsC;;AAAA,UAC3FpH,IAD2F,GACvE4E,KADuE,CAC3F5E,IAD2F;AAAA,UACrFd,SADqF,GACvE0F,KADuE,CACrF1F,SADqF;AAEnG,UAAMH,IAAqB,GAAGmI,KAAK,CAACC,OAAD,CAAnC;AACA,UAAMjB,aAAqB,GAAG,OAAOnH,IAAP,KAAgB,QAAhB,GAC1BA,IAAI,GAAG,CADmB,GAE1B,KAAKoH,mBAAL,CAAyBnG,IAAzB,EAA+Bd,SAA/B,EAA0CiI,OAAO,GAAGC,SAApD,CAFJ;AAGA,aAAOlB,aAAP;AACH;;;;;;;;"}