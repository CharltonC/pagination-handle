{"version":3,"file":"index.js","sources":["../../src/index.ts"],"sourcesContent":["import {\n    IState, IOption,\n    IPageNavQuery,\n    IPageCtx, IPageSlice, IPageRange, IRelPage, IRelPageCtx, IRecordCtx, ISpreadCtx, TSpreadCtx,\n    ICmpAttrQuery, ICmpAttr, ICmpBtnAttr, ICmpSelectAttr, ISelectEvt, TPageList,\n    TFn\n} from './type';\n\n/**\n * Usage:\n *      const list = ['a', 'b', 'c', 'd'];\n *      const totalRecord = list.length;\n *\n *      const example = pgnHandle.getState(totalRecord, {\n *           page: 1,                       // optional starting page index\n *           increment: [100, 200, 300],    // used for <select>'s <option> (default 10 per page, i.e. [10])\n *           incrementIdx: 0,               // i.e. 100 per age\n *      });\n *\n *      const { startIdx, endIdx } = example;\n *      const listFor1stPage = list.slice(startIdx, endIdx);\n */\nclass PgnHandle {\n    //// Option\n    /**\n     * Merge the updated option with existing option (either custom or default)\n     * e.g. existingOption = this.state.sortOption\n     */\n    getOption(modOption: Partial<IOption>, existingOption?: IOption): IOption {\n        const baseOption = existingOption ? existingOption : this.getDefOption();\n        return { ...baseOption, ...modOption };\n    }\n\n    getDefOption(): IOption {\n        return {\n            page: 0,\n            increment: [10],\n            incrementIdx: 0,\n            maxSpread: 3\n        };\n    }\n\n    //// Full State\n    getState(totalRecord: number, pgnOption: Partial<IOption>): IState {\n        // Merge def. option with User's option\n        const defOption: IOption = this.getDefOption();\n        const { increment: [defIncrmVal] } = defOption;\n        const { page, increment, incrementIdx, maxSpread } = Object.assign(defOption, pgnOption);\n        let perPage: number = this.getNoPerPage(increment, incrementIdx, defIncrmVal);\n\n        // Skip if we only have 1 list item OR less than 2 pages\n        const defState: IState = this.getDefState(totalRecord, perPage);\n        if (totalRecord <= 1) return defState;\n        const totalPage: number = this.getTotalPage(totalRecord, perPage);\n        if (totalPage <= 1) return defState;\n\n        // Proceed as we have >=2 pages\n        const { curr, pageNo }: IPageCtx = this.getCurrPage(page, totalPage - 1);\n        const currSlice: IPageSlice = this.getPageSliceIdx(totalRecord, perPage, curr);\n        const { startIdx, endIdx } = currSlice;\n        const recordCtx = this.getRecordCtx(totalRecord, startIdx, endIdx);\n        const spreadCtx: ISpreadCtx = this.getSpreadCtx(pageNo, totalPage, maxSpread);\n        let relPage: IRelPage = this.getRelPage(totalPage, curr);\n        const relPageCtx: IRelPageCtx = this.getRelPageCtx({ curr, last: relPage.last }, relPage);\n        relPage = this.parseRelPage(relPage, relPageCtx);\n\n        return { curr, ...relPage, ...currSlice, pageNo, perPage, totalPage, ...recordCtx, ...spreadCtx };\n    }\n\n    getDefState(totalRecord: number, perPage: number): IState {\n        const startIdx: number = 0;\n        const recordCtx: IRecordCtx = this.getRecordCtx(totalRecord, startIdx);\n        return {\n            ...recordCtx,\n            perPage,\n            totalPage: 1,\n            startIdx,\n            pageNo: 1\n        } as IState;\n    }\n\n    //// Partial State\n    getRecordCtx(totalRecord: number, startIdx: number, endIdx?: number): IRecordCtx {\n        const hsRecord: boolean = totalRecord >= 1;\n        return {\n            startRecord: (hsRecord && Number.isInteger(startIdx)) ? startIdx + 1 : 0,\n            endRecord: (hsRecord && Number.isInteger(endIdx)) ? endIdx : totalRecord,\n            totalRecord\n        };\n    }\n\n    getNoPerPage(incrms: number[], incrmIdx: number, fallbackVal: number): number {\n        const hsIncrms: boolean = !!incrms.length;\n        if (!hsIncrms) return fallbackVal;\n\n        const incrm: number = incrms[incrmIdx];\n        const isValidIncrm: boolean = Number.isInteger(incrm) && incrm > 0;\n        const perPage: number = isValidIncrm ? incrms[incrmIdx] : fallbackVal;\n        return perPage;\n    }\n\n    parseNoPerPage(incrms: number[]): number[] {\n        return incrms.filter((incrm: number) => {\n            return Number.isInteger(incrm) && incrm > 0;\n        });\n    }\n\n    getTotalPage(lsLen: number, perPage: number): number {\n        const noOfPage: number = (lsLen > perPage) ? lsLen / perPage : 1;\n        return Math.ceil(noOfPage);\n    }\n\n    getCurrPage(page: number, lastPage: number): IPageCtx {\n        const curr: number = (page >= 0 && page <= lastPage) ? page : 0;\n        const pageNo: number = curr + 1;\n        return { curr, pageNo };\n    }\n\n    getRelPage(totalPage: number, currPage: number): IRelPage {\n        return {\n            first: 0,\n            prev: currPage - 1,\n            next: currPage + 1,\n            last: totalPage - 1\n        };\n    }\n\n    getRelPageCtx(pageRange: IPageRange, relPage: IRelPage): IRelPageCtx {\n        const relPageKeys = Object.getOwnPropertyNames(relPage) as (keyof IRelPage)[];\n        return relPageKeys.reduce((relPageCtx, type: string) => {\n            const pageQuery: IPageNavQuery = { type, target: relPage[type] };\n            relPageCtx[type] = this.canNavToPage(pageRange, pageQuery);\n            return relPageCtx;\n        }, {}) as IRelPageCtx;\n    }\n\n    parseRelPage(relPage: IRelPage, relPageCtx: IRelPageCtx): IRelPage {\n        const relPageKeys = Object.getOwnPropertyNames(relPage) as (keyof IRelPage)[];\n        relPageKeys.forEach((pageType: keyof IRelPage) => {\n            const page: number = relPage[pageType];\n            relPage[pageType] = relPageCtx[pageType] ? page : null;\n        });\n        return relPage;\n    }\n\n    getPageSliceIdx(totalRecord: number, perPage: number, page: number): IPageSlice {\n        let startIdx: number = page * perPage;     // inclusive index\n        let endIdx: number = startIdx + perPage;      // exclusive index\n        startIdx = startIdx < totalRecord ? startIdx : undefined;   // `undefined` is used as `null` cant be used as empty value in ES6\n        endIdx = endIdx < totalRecord ? endIdx : undefined;\n        return { startIdx, endIdx };\n    }\n\n    /**\n     * Get the page number for the left/right spread in relation to current page\n     * - When remain < maxSpread, show `maxSpread` no. of pages\n     * - When remain > maxSpread, show dots (either on left/right) + `maxSpread` no. of pages\n     * - when remain < 1, no spread is available\n     *\n     * @param maxSpread: max no. of pages for each side of the spread\n     */\n    getSpreadCtx(currPageNo: number, totalPage: number, maxSpread: number = 3): ISpreadCtx {\n        // 1 is added to `spreadRange` in case there is '...' for either 1st/last item\n        const spreadRange: any[] = [...Array(maxSpread + 1)];\n        const firstPage: number = 1;\n        const DOTS = '...';\n\n        const rtTotalRemain: number = totalPage - currPageNo;\n        const ltTotalRemain: number = currPageNo - firstPage;\n        const hsRtSpread: boolean = rtTotalRemain > 1 && rtTotalRemain < totalPage;\n        const hsLtSpread: boolean = ltTotalRemain > 1 && ltTotalRemain < totalPage;\n\n        const rtSpread: TSpreadCtx = hsRtSpread ?\n            spreadRange.reduce((container: TSpreadCtx, item, idx: number) => {\n                const pageNo: number = currPageNo + idx + 1;\n\n                // We exclude the 1st page or last page since its already available in the Pagination state\n                const isInRange: boolean = pageNo > 1 && pageNo < totalPage;\n\n                // Check if there is any pages between \"last\" page number in this loop and the actual last page\n                // - e.g. last page in the loop is: 8 | actual last page is: 10,\n                // so we have page 9 in between, which we can use '...' to represent\n                const hsGtOnePageTilLastPage: boolean = idx === maxSpread && (totalPage - pageNo) >= 1;\n\n                if (isInRange) container.push(hsGtOnePageTilLastPage ? DOTS : pageNo);\n                return container;\n            }, []) :\n            null;\n\n        const ltSpread: TSpreadCtx = hsLtSpread ?\n            spreadRange.reduce((container: TSpreadCtx, item, idx: number) => {\n                const pageNo: number = currPageNo - idx - 1;\n                const isInRange: boolean = pageNo > 1 && pageNo < totalPage;\n                const hsGtOnePageTilFirstPage: boolean = idx === maxSpread && (currPageNo - pageNo) >= 1;\n                if (isInRange) container.unshift(hsGtOnePageTilFirstPage ? DOTS : pageNo);\n                return container;\n            }, []) :\n            null;\n\n        return { ltSpread, rtSpread, maxSpread };\n    }\n\n    /**\n     * Forumla for calculating corresponding page index for left/right spread '...' based on the\n     * context of current page and the maxSpread (no. of pages between current and target page)\n     *\n     * e.g. maxSpread = 3\n     * ------------------------------------------------------------\n     * Current Page          | Spread/Target Page    | Spread Type\n     * No.      | Index      | No.      | Index      |\n     * ------------------------------------------------------------\n     * 1          0            4          3            Right Spread\n     * 10         9            6          5            Left Spread\n     */\n    getPageIdxForSpread(currPageIdx: number, maxSpread: number, isLtSpread: boolean): number {\n        return isLtSpread ?\n            (currPageIdx - maxSpread - 1) :\n            (currPageIdx + maxSpread + 1) ;\n    }\n\n    //// Helper Methods\n    canNavToPage({ curr, last }: IPageRange, { type, target }: IPageNavQuery): boolean {\n        if (!this.isGteZero([curr, last])) return false;\n\n        switch (type) {\n            case 'prev':\n                // we dont need `target < curr` since we already know `target = curr - 1;`\n                return target >= 0;\n            case 'next':\n                // we dont need `target > curr` since we already know `target = curr + 1;`\n                return target <= last;\n            case 'first':\n                // we dont need `target > curr` since we already know `target = 0`\n                return curr !== 0 && target < curr;\n            case 'last':\n                return target > curr;\n            case 'page':\n                // i.e. any prev or next\n                return this.isGteZero(target) && target !== curr && target <= last;\n            default:\n                return false;\n        }\n    }\n\n    isGteZero(vals: any | any[]): boolean {\n        return Array.isArray(vals) ?\n            vals.every((val: any) => (Number.isInteger(val) && val >= 0)) :\n            Number.isInteger(vals) && vals >= 0;\n    }\n\n    //// Generic UI Component Related\n    /**\n     * Create Generic Attributes that can be passed/mapped to Attributes/Inputs/Props of Static HTML or Angular/React/Vue/etc Components\n     *\n     * - Usage Example for React:\n     * const callback = (modState => this.setState({...this.state, ...modState})).bind(this);\n     * createGenericCmpProps({option, state, data, callback});\n     */\n    createGenericCmpAttr({ totalRecord, option, state, callback }: ICmpAttrQuery): ICmpAttr {\n        const { first, prev, next, last, ltSpread, rtSpread } = state;\n        const onEvt: TFn = this.getGenericCmpEvtHandler(totalRecord, option, callback);\n\n        return {\n            // Attr. for First/Prev/Next/Last as Button\n            firstBtnAttr: this.getTextBtnAttr(onEvt, ['first', first]),\n            prevBtnAttr: this.getTextBtnAttr(onEvt, ['prev', prev]),\n            nextBtnAttr: this.getTextBtnAttr(onEvt, ['next', next]),\n            lastBtnAttr: this.getTextBtnAttr(onEvt, ['last', last]),\n\n            // Attr. for Spread as Button\n            ltSpreadBtnsAttr: ltSpread ?\n                ltSpread.map((page: number) => this.getSpreadBtnAttr(onEvt, state, [page, true])) :\n                null,\n            rtSpreadBtnsAttr: rtSpread ?\n                rtSpread.map((page: number) => this.getSpreadBtnAttr(onEvt, state, [page, false])) :\n                null,\n\n            // Attr. for Page Select and Per Page Select\n            perPageSelectAttr: this.getPerPageSelectAttr(onEvt, option),\n            pageSelectAttr: this.getPageSelectAttr(onEvt, state),\n        };\n    }\n\n    getTextBtnAttr(onEvt: TFn, [title, pageIdx]: [string, number]): ICmpBtnAttr {\n        return {\n            title,\n            disabled: !Number.isInteger(pageIdx),\n            onClick: () => onEvt({\n                page: pageIdx\n            })\n        };\n    }\n\n    getSpreadBtnAttr(onEvt: TFn, state: IState, [page, isLtSpread]: [any, boolean]): ICmpBtnAttr {\n        const { curr, maxSpread } = state;\n\n        // If the page is not a number, then its likely dots '...' so page is jumped by an interval of `maxSpread`\n        // - e.g. maxSpread = 3, currPageNo = 6\n        // then the page is jumped to 2 (eqv. to page index of 3)\n        const isNum: boolean = typeof page === 'number';\n        // const pageIdx = isNum ? page - 1 : curr;\n        const targetPageIdx: number = isLtSpread ?\n            (isNum ? curr - 1 : this.getPageIdxForSpread(curr, maxSpread, true) ):\n            (isNum ? curr + 1 : this.getPageIdxForSpread(curr, maxSpread, false));\n\n        return {\n            title: isNum ? page : (isLtSpread ? 'left-spread' : 'right-spread'),\n            isSpread: !isNum,\n            onClick: () => onEvt({\n                page: targetPageIdx\n            })\n        };\n    }\n\n    getPageSelectAttr(onEvt: TFn, state: IState): ICmpSelectAttr {\n        const { pageNo, totalPage, ltSpread, rtSpread } = state;\n\n        const isLteOnePage: boolean = totalPage <= 1;\n\n        // Options (inclusive of all pages here)\n        const leftOptions: TPageList = (isLteOnePage || pageNo === 1) ?\n            [ 1 ] :\n            [ 1, ...(ltSpread ? ltSpread : []), pageNo ];\n\n        const rightOptions: TPageList = (isLteOnePage || pageNo === totalPage) ?\n            [] :\n            [ ...(rtSpread ? rtSpread : []), totalPage ];\n\n        const options: TPageList = [ ...leftOptions, ...rightOptions ];\n        const selectedOptionIdx: number = leftOptions.length - 1;\n\n        return {\n            title: 'page select',\n            disabled: isLteOnePage,\n            options,\n            selectedOptionValue: pageNo,\n            selectedOptionIdx,\n            onSelect: ({ target }: ISelectEvt) => {\n                const targetPageIdx: number = this.getTargetPageIdxByPos(\n                    state,\n                    options,\n                    [ parseInt(target.value, 10), selectedOptionIdx ]\n                );\n                onEvt({ page: targetPageIdx });\n            }\n        };\n    }\n\n    getPerPageSelectAttr(onEvt: TFn, option: IOption): ICmpSelectAttr {\n        const { increment, incrementIdx } = option;\n        return {\n            title: 'per page select',\n            disabled: increment.length <= 1,\n            options: increment,\n            selectedOptionValue: increment[incrementIdx],\n            selectedOptionIdx: incrementIdx,\n            onSelect: ({ target }: ISelectEvt) => onEvt({\n                page: 0,\n                incrementIdx: parseInt(target.value, 10)\n            })\n        };\n    }\n\n    getGenericCmpEvtHandler(totalRecord: number, option: IOption, callback?: TFn): TFn {\n        return ((modOption: Partial<IOption>): void => {\n            const pgnOption: IOption = this.getOption(modOption, option);\n            const pgnState: IState = this.getState(totalRecord, pgnOption);\n            if (callback) callback({ pgnOption, pgnState });\n        });\n    }\n\n    getTargetPageIdxByPos(state: IState, pages: TPageList, [currPos, activePos]: [number, number]): number {\n        const { curr, maxSpread } = state;\n        const page: string | number = pages[currPos];\n        const targetPageIdx: number = typeof page === 'number' ?\n            page - 1 :\n            this.getPageIdxForSpread(curr, maxSpread, currPos < activePos);\n        return targetPageIdx;\n    }\n}\n\nexport default PgnHandle;"],"names":["PgnHandle","modOption","existingOption","baseOption","getDefOption","page","increment","incrementIdx","maxSpread","totalRecord","pgnOption","defOption","defIncrmVal","Object","assign","perPage","getNoPerPage","defState","getDefState","totalPage","getTotalPage","getCurrPage","curr","pageNo","currSlice","getPageSliceIdx","startIdx","endIdx","recordCtx","getRecordCtx","spreadCtx","getSpreadCtx","relPage","getRelPage","relPageCtx","getRelPageCtx","last","parseRelPage","hsRecord","startRecord","Number","isInteger","endRecord","incrms","incrmIdx","fallbackVal","hsIncrms","length","incrm","isValidIncrm","filter","lsLen","noOfPage","Math","ceil","lastPage","currPage","first","prev","next","pageRange","relPageKeys","getOwnPropertyNames","reduce","type","pageQuery","target","canNavToPage","forEach","pageType","undefined","currPageNo","spreadRange","Array","firstPage","DOTS","rtTotalRemain","ltTotalRemain","hsRtSpread","hsLtSpread","rtSpread","container","item","idx","isInRange","hsGtOnePageTilLastPage","push","ltSpread","hsGtOnePageTilFirstPage","unshift","currPageIdx","isLtSpread","isGteZero","vals","isArray","every","val","option","state","callback","onEvt","getGenericCmpEvtHandler","firstBtnAttr","getTextBtnAttr","prevBtnAttr","nextBtnAttr","lastBtnAttr","ltSpreadBtnsAttr","map","getSpreadBtnAttr","rtSpreadBtnsAttr","perPageSelectAttr","getPerPageSelectAttr","pageSelectAttr","getPageSelectAttr","title","pageIdx","disabled","onClick","isNum","targetPageIdx","getPageIdxForSpread","isSpread","isLteOnePage","leftOptions","rightOptions","options","selectedOptionIdx","selectedOptionValue","onSelect","getTargetPageIdxByPos","parseInt","value","getOption","pgnState","getState","pages","currPos","activePos"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAQA;;;;;;;;;;;;;;MAcMA;;;;;;;EACF;;EACA;;;;gCAIUC,WAA6BC,gBAAmC;EACtE,UAAMC,UAAU,GAAGD,cAAc,GAAGA,cAAH,GAAoB,KAAKE,YAAL,EAArD;EACA,+CAAYD,UAAZ,GAA2BF,SAA3B;EACH;;;qCAEuB;EACpB,aAAO;EACHI,QAAAA,IAAI,EAAE,CADH;EAEHC,QAAAA,SAAS,EAAE,CAAC,EAAD,CAFR;EAGHC,QAAAA,YAAY,EAAE,CAHX;EAIHC,QAAAA,SAAS,EAAE;EAJR,OAAP;EAMH;;;;+BAGQC,aAAqBC,WAAqC;EAC/D;EACA,UAAMC,SAAkB,GAAG,KAAKP,YAAL,EAA3B;;EAF+D,gDAG1BO,SAH0B,CAGvDL,SAHuD;EAAA,UAG3CM,WAH2C;;EAAA,2BAIVC,MAAM,CAACC,MAAP,CAAcH,SAAd,EAAyBD,SAAzB,CAJU;EAAA,UAIvDL,IAJuD,kBAIvDA,IAJuD;EAAA,UAIjDC,SAJiD,kBAIjDA,SAJiD;EAAA,UAItCC,YAJsC,kBAItCA,YAJsC;EAAA,UAIxBC,SAJwB,kBAIxBA,SAJwB;;EAK/D,UAAIO,OAAe,GAAG,KAAKC,YAAL,CAAkBV,SAAlB,EAA6BC,YAA7B,EAA2CK,WAA3C,CAAtB,CAL+D;;EAQ/D,UAAMK,QAAgB,GAAG,KAAKC,WAAL,CAAiBT,WAAjB,EAA8BM,OAA9B,CAAzB;EACA,UAAIN,WAAW,IAAI,CAAnB,EAAsB,OAAOQ,QAAP;EACtB,UAAME,SAAiB,GAAG,KAAKC,YAAL,CAAkBX,WAAlB,EAA+BM,OAA/B,CAA1B;EACA,UAAII,SAAS,IAAI,CAAjB,EAAoB,OAAOF,QAAP,CAX2C;;EAAA,8BAc5B,KAAKI,WAAL,CAAiBhB,IAAjB,EAAuBc,SAAS,GAAG,CAAnC,CAd4B;EAAA,UAcvDG,IAduD,qBAcvDA,IAduD;EAAA,UAcjDC,MAdiD,qBAcjDA,MAdiD;;EAe/D,UAAMC,SAAqB,GAAG,KAAKC,eAAL,CAAqBhB,WAArB,EAAkCM,OAAlC,EAA2CO,IAA3C,CAA9B;EAf+D,UAgBvDI,QAhBuD,GAgBlCF,SAhBkC,CAgBvDE,QAhBuD;EAAA,UAgB7CC,MAhB6C,GAgBlCH,SAhBkC,CAgB7CG,MAhB6C;EAiB/D,UAAMC,SAAS,GAAG,KAAKC,YAAL,CAAkBpB,WAAlB,EAA+BiB,QAA/B,EAAyCC,MAAzC,CAAlB;EACA,UAAMG,SAAqB,GAAG,KAAKC,YAAL,CAAkBR,MAAlB,EAA0BJ,SAA1B,EAAqCX,SAArC,CAA9B;EACA,UAAIwB,OAAiB,GAAG,KAAKC,UAAL,CAAgBd,SAAhB,EAA2BG,IAA3B,CAAxB;EACA,UAAMY,UAAuB,GAAG,KAAKC,aAAL,CAAmB;EAAEb,QAAAA,IAAI,EAAJA,IAAF;EAAQc,QAAAA,IAAI,EAAEJ,OAAO,CAACI;EAAtB,OAAnB,EAAiDJ,OAAjD,CAAhC;EACAA,MAAAA,OAAO,GAAG,KAAKK,YAAL,CAAkBL,OAAlB,EAA2BE,UAA3B,CAAV;EAEA;EAASZ,QAAAA,IAAI,EAAJA;EAAT,SAAkBU,OAAlB,GAA8BR,SAA9B;EAAyCD,QAAAA,MAAM,EAANA,MAAzC;EAAiDR,QAAAA,OAAO,EAAPA,OAAjD;EAA0DI,QAAAA,SAAS,EAATA;EAA1D,SAAwES,SAAxE,GAAsFE,SAAtF;EACH;;;kCAEWrB,aAAqBM,SAAyB;EACtD,UAAMW,QAAgB,GAAG,CAAzB;EACA,UAAME,SAAqB,GAAG,KAAKC,YAAL,CAAkBpB,WAAlB,EAA+BiB,QAA/B,CAA9B;EACA,+CACOE,SADP;EAEIb,QAAAA,OAAO,EAAPA,OAFJ;EAGII,QAAAA,SAAS,EAAE,CAHf;EAIIO,QAAAA,QAAQ,EAARA,QAJJ;EAKIH,QAAAA,MAAM,EAAE;EALZ;EAOH;;;;mCAGYd,aAAqBiB,UAAkBC,QAA6B;EAC7E,UAAMW,QAAiB,GAAG7B,WAAW,IAAI,CAAzC;EACA,aAAO;EACH8B,QAAAA,WAAW,EAAGD,QAAQ,IAAIE,MAAM,CAACC,SAAP,CAAiBf,QAAjB,CAAb,GAA2CA,QAAQ,GAAG,CAAtD,GAA0D,CADpE;EAEHgB,QAAAA,SAAS,EAAGJ,QAAQ,IAAIE,MAAM,CAACC,SAAP,CAAiBd,MAAjB,CAAb,GAAyCA,MAAzC,GAAkDlB,WAF1D;EAGHA,QAAAA,WAAW,EAAXA;EAHG,OAAP;EAKH;;;mCAEYkC,QAAkBC,UAAkBC,aAA6B;EAC1E,UAAMC,QAAiB,GAAG,CAAC,CAACH,MAAM,CAACI,MAAnC;EACA,UAAI,CAACD,QAAL,EAAe,OAAOD,WAAP;EAEf,UAAMG,KAAa,GAAGL,MAAM,CAACC,QAAD,CAA5B;EACA,UAAMK,YAAqB,GAAGT,MAAM,CAACC,SAAP,CAAiBO,KAAjB,KAA2BA,KAAK,GAAG,CAAjE;EACA,UAAMjC,OAAe,GAAGkC,YAAY,GAAGN,MAAM,CAACC,QAAD,CAAT,GAAsBC,WAA1D;EACA,aAAO9B,OAAP;EACH;;;qCAEc4B,QAA4B;EACvC,aAAOA,MAAM,CAACO,MAAP,CAAc,UAACF,KAAD,EAAmB;EACpC,eAAOR,MAAM,CAACC,SAAP,CAAiBO,KAAjB,KAA2BA,KAAK,GAAG,CAA1C;EACH,OAFM,CAAP;EAGH;;;mCAEYG,OAAepC,SAAyB;EACjD,UAAMqC,QAAgB,GAAID,KAAK,GAAGpC,OAAT,GAAoBoC,KAAK,GAAGpC,OAA5B,GAAsC,CAA/D;EACA,aAAOsC,IAAI,CAACC,IAAL,CAAUF,QAAV,CAAP;EACH;;;kCAEW/C,MAAckD,UAA4B;EAClD,UAAMjC,IAAY,GAAIjB,IAAI,IAAI,CAAR,IAAaA,IAAI,IAAIkD,QAAtB,GAAkClD,IAAlC,GAAyC,CAA9D;EACA,UAAMkB,MAAc,GAAGD,IAAI,GAAG,CAA9B;EACA,aAAO;EAAEA,QAAAA,IAAI,EAAJA,IAAF;EAAQC,QAAAA,MAAM,EAANA;EAAR,OAAP;EACH;;;iCAEUJ,WAAmBqC,UAA4B;EACtD,aAAO;EACHC,QAAAA,KAAK,EAAE,CADJ;EAEHC,QAAAA,IAAI,EAAEF,QAAQ,GAAG,CAFd;EAGHG,QAAAA,IAAI,EAAEH,QAAQ,GAAG,CAHd;EAIHpB,QAAAA,IAAI,EAAEjB,SAAS,GAAG;EAJf,OAAP;EAMH;;;oCAEayC,WAAuB5B,SAAgC;EAAA;;EACjE,UAAM6B,WAAW,GAAGhD,MAAM,CAACiD,mBAAP,CAA2B9B,OAA3B,CAApB;EACA,aAAO6B,WAAW,CAACE,MAAZ,CAAmB,UAAC7B,UAAD,EAAa8B,IAAb,EAA8B;EACpD,YAAMC,SAAwB,GAAG;EAAED,UAAAA,IAAI,EAAJA,IAAF;EAAQE,UAAAA,MAAM,EAAElC,OAAO,CAACgC,IAAD;EAAvB,SAAjC;EACA9B,QAAAA,UAAU,CAAC8B,IAAD,CAAV,GAAmB,KAAI,CAACG,YAAL,CAAkBP,SAAlB,EAA6BK,SAA7B,CAAnB;EACA,eAAO/B,UAAP;EACH,OAJM,EAIJ,EAJI,CAAP;EAKH;;;mCAEYF,SAAmBE,YAAmC;EAC/D,UAAM2B,WAAW,GAAGhD,MAAM,CAACiD,mBAAP,CAA2B9B,OAA3B,CAApB;EACA6B,MAAAA,WAAW,CAACO,OAAZ,CAAoB,UAACC,QAAD,EAA8B;EAC9C,YAAMhE,IAAY,GAAG2B,OAAO,CAACqC,QAAD,CAA5B;EACArC,QAAAA,OAAO,CAACqC,QAAD,CAAP,GAAoBnC,UAAU,CAACmC,QAAD,CAAV,GAAuBhE,IAAvB,GAA8B,IAAlD;EACH,OAHD;EAIA,aAAO2B,OAAP;EACH;;;sCAEevB,aAAqBM,SAAiBV,MAA0B;EAC5E,UAAIqB,QAAgB,GAAGrB,IAAI,GAAGU,OAA9B,CAD4E;;EAE5E,UAAIY,MAAc,GAAGD,QAAQ,GAAGX,OAAhC,CAF4E;;EAG5EW,MAAAA,QAAQ,GAAGA,QAAQ,GAAGjB,WAAX,GAAyBiB,QAAzB,GAAoC4C,SAA/C,CAH4E;;EAI5E3C,MAAAA,MAAM,GAAGA,MAAM,GAAGlB,WAAT,GAAuBkB,MAAvB,GAAgC2C,SAAzC;EACA,aAAO;EAAE5C,QAAAA,QAAQ,EAARA,QAAF;EAAYC,QAAAA,MAAM,EAANA;EAAZ,OAAP;EACH;EAED;;;;;;;;;;;mCAQa4C,YAAoBpD,WAAsD;EAAA,UAAnCX,SAAmC,uEAAf,CAAe;;EACnF;EACA,UAAMgE,WAAkB,sBAAOC,KAAK,CAACjE,SAAS,GAAG,CAAb,CAAZ,CAAxB;;EACA,UAAMkE,SAAiB,GAAG,CAA1B;EACA,UAAMC,IAAI,GAAG,KAAb;EAEA,UAAMC,aAAqB,GAAGzD,SAAS,GAAGoD,UAA1C;EACA,UAAMM,aAAqB,GAAGN,UAAU,GAAGG,SAA3C;EACA,UAAMI,UAAmB,GAAGF,aAAa,GAAG,CAAhB,IAAqBA,aAAa,GAAGzD,SAAjE;EACA,UAAM4D,UAAmB,GAAGF,aAAa,GAAG,CAAhB,IAAqBA,aAAa,GAAG1D,SAAjE;EAEA,UAAM6D,QAAoB,GAAGF,UAAU,GACnCN,WAAW,CAACT,MAAZ,CAAmB,UAACkB,SAAD,EAAwBC,IAAxB,EAA8BC,GAA9B,EAA8C;EAC7D,YAAM5D,MAAc,GAAGgD,UAAU,GAAGY,GAAb,GAAmB,CAA1C,CAD6D;;EAI7D,YAAMC,SAAkB,GAAG7D,MAAM,GAAG,CAAT,IAAcA,MAAM,GAAGJ,SAAlD,CAJ6D;EAO7D;EACA;;EACA,YAAMkE,sBAA+B,GAAGF,GAAG,KAAK3E,SAAR,IAAsBW,SAAS,GAAGI,MAAb,IAAwB,CAArF;EAEA,YAAI6D,SAAJ,EAAeH,SAAS,CAACK,IAAV,CAAeD,sBAAsB,GAAGV,IAAH,GAAUpD,MAA/C;EACf,eAAO0D,SAAP;EACH,OAbD,EAaG,EAbH,CADmC,GAenC,IAfJ;EAiBA,UAAMM,QAAoB,GAAGR,UAAU,GACnCP,WAAW,CAACT,MAAZ,CAAmB,UAACkB,SAAD,EAAwBC,IAAxB,EAA8BC,GAA9B,EAA8C;EAC7D,YAAM5D,MAAc,GAAGgD,UAAU,GAAGY,GAAb,GAAmB,CAA1C;EACA,YAAMC,SAAkB,GAAG7D,MAAM,GAAG,CAAT,IAAcA,MAAM,GAAGJ,SAAlD;EACA,YAAMqE,uBAAgC,GAAGL,GAAG,KAAK3E,SAAR,IAAsB+D,UAAU,GAAGhD,MAAd,IAAyB,CAAvF;EACA,YAAI6D,SAAJ,EAAeH,SAAS,CAACQ,OAAV,CAAkBD,uBAAuB,GAAGb,IAAH,GAAUpD,MAAnD;EACf,eAAO0D,SAAP;EACH,OAND,EAMG,EANH,CADmC,GAQnC,IARJ;EAUA,aAAO;EAAEM,QAAAA,QAAQ,EAARA,QAAF;EAAYP,QAAAA,QAAQ,EAARA,QAAZ;EAAsBxE,QAAAA,SAAS,EAATA;EAAtB,OAAP;EACH;EAED;;;;;;;;;;;;;;;0CAYoBkF,aAAqBlF,WAAmBmF,YAA6B;EACrF,aAAOA,UAAU,GACZD,WAAW,GAAGlF,SAAd,GAA0B,CADd,GAEZkF,WAAW,GAAGlF,SAAd,GAA0B,CAF/B;EAGH;;;;gDAGkF;EAAA,UAApEc,IAAoE,QAApEA,IAAoE;EAAA,UAA9Dc,IAA8D,QAA9DA,IAA8D;EAAA,UAAxC4B,IAAwC,SAAxCA,IAAwC;EAAA,UAAlCE,MAAkC,SAAlCA,MAAkC;EAC/E,UAAI,CAAC,KAAK0B,SAAL,CAAe,CAACtE,IAAD,EAAOc,IAAP,CAAf,CAAL,EAAmC,OAAO,KAAP;;EAEnC,cAAQ4B,IAAR;EACI,aAAK,MAAL;EACI;EACA,iBAAOE,MAAM,IAAI,CAAjB;;EACJ,aAAK,MAAL;EACI;EACA,iBAAOA,MAAM,IAAI9B,IAAjB;;EACJ,aAAK,OAAL;EACI;EACA,iBAAOd,IAAI,KAAK,CAAT,IAAc4C,MAAM,GAAG5C,IAA9B;;EACJ,aAAK,MAAL;EACI,iBAAO4C,MAAM,GAAG5C,IAAhB;;EACJ,aAAK,MAAL;EACI;EACA,iBAAO,KAAKsE,SAAL,CAAe1B,MAAf,KAA0BA,MAAM,KAAK5C,IAArC,IAA6C4C,MAAM,IAAI9B,IAA9D;;EACJ;EACI,iBAAO,KAAP;EAhBR;EAkBH;;;gCAESyD,MAA4B;EAClC,aAAOpB,KAAK,CAACqB,OAAN,CAAcD,IAAd,IACHA,IAAI,CAACE,KAAL,CAAW,UAACC,GAAD;EAAA,eAAexD,MAAM,CAACC,SAAP,CAAiBuD,GAAjB,KAAyBA,GAAG,IAAI,CAA/C;EAAA,OAAX,CADG,GAEHxD,MAAM,CAACC,SAAP,CAAiBoD,IAAjB,KAA0BA,IAAI,IAAI,CAFtC;EAGH;;EAGD;;;;;;;;;;kDAOwF;EAAA;;EAAA,UAAjEpF,WAAiE,SAAjEA,WAAiE;EAAA,UAApDwF,MAAoD,SAApDA,MAAoD;EAAA,UAA5CC,KAA4C,SAA5CA,KAA4C;EAAA,UAArCC,QAAqC,SAArCA,QAAqC;EAAA,UAC5E1C,KAD4E,GAC5ByC,KAD4B,CAC5EzC,KAD4E;EAAA,UACrEC,IADqE,GAC5BwC,KAD4B,CACrExC,IADqE;EAAA,UAC/DC,IAD+D,GAC5BuC,KAD4B,CAC/DvC,IAD+D;EAAA,UACzDvB,IADyD,GAC5B8D,KAD4B,CACzD9D,IADyD;EAAA,UACnDmD,QADmD,GAC5BW,KAD4B,CACnDX,QADmD;EAAA,UACzCP,QADyC,GAC5BkB,KAD4B,CACzClB,QADyC;EAEpF,UAAMoB,KAAU,GAAG,KAAKC,uBAAL,CAA6B5F,WAA7B,EAA0CwF,MAA1C,EAAkDE,QAAlD,CAAnB;EAEA,aAAO;EACH;EACAG,QAAAA,YAAY,EAAE,KAAKC,cAAL,CAAoBH,KAApB,EAA2B,CAAC,OAAD,EAAU3C,KAAV,CAA3B,CAFX;EAGH+C,QAAAA,WAAW,EAAE,KAAKD,cAAL,CAAoBH,KAApB,EAA2B,CAAC,MAAD,EAAS1C,IAAT,CAA3B,CAHV;EAIH+C,QAAAA,WAAW,EAAE,KAAKF,cAAL,CAAoBH,KAApB,EAA2B,CAAC,MAAD,EAASzC,IAAT,CAA3B,CAJV;EAKH+C,QAAAA,WAAW,EAAE,KAAKH,cAAL,CAAoBH,KAApB,EAA2B,CAAC,MAAD,EAAShE,IAAT,CAA3B,CALV;EAOH;EACAuE,QAAAA,gBAAgB,EAAEpB,QAAQ,GACtBA,QAAQ,CAACqB,GAAT,CAAa,UAACvG,IAAD;EAAA,iBAAkB,MAAI,CAACwG,gBAAL,CAAsBT,KAAtB,EAA6BF,KAA7B,EAAoC,CAAC7F,IAAD,EAAO,IAAP,CAApC,CAAlB;EAAA,SAAb,CADsB,GAEtB,IAVD;EAWHyG,QAAAA,gBAAgB,EAAE9B,QAAQ,GACtBA,QAAQ,CAAC4B,GAAT,CAAa,UAACvG,IAAD;EAAA,iBAAkB,MAAI,CAACwG,gBAAL,CAAsBT,KAAtB,EAA6BF,KAA7B,EAAoC,CAAC7F,IAAD,EAAO,KAAP,CAApC,CAAlB;EAAA,SAAb,CADsB,GAEtB,IAbD;EAeH;EACA0G,QAAAA,iBAAiB,EAAE,KAAKC,oBAAL,CAA0BZ,KAA1B,EAAiCH,MAAjC,CAhBhB;EAiBHgB,QAAAA,cAAc,EAAE,KAAKC,iBAAL,CAAuBd,KAAvB,EAA8BF,KAA9B;EAjBb,OAAP;EAmBH;;;qCAEcE,cAA6D;EAAA;EAAA,UAAhDe,KAAgD;EAAA,UAAzCC,OAAyC;;EACxE,aAAO;EACHD,QAAAA,KAAK,EAALA,KADG;EAEHE,QAAAA,QAAQ,EAAE,CAAC7E,MAAM,CAACC,SAAP,CAAiB2E,OAAjB,CAFR;EAGHE,QAAAA,OAAO,EAAE;EAAA,iBAAMlB,KAAK,CAAC;EACjB/F,YAAAA,IAAI,EAAE+G;EADW,WAAD,CAAX;EAAA;EAHN,OAAP;EAOH;;;uCAEgBhB,OAAYF,cAAgE;EAAA;EAAA,UAAhD7F,IAAgD;EAAA,UAA1CsF,UAA0C;;EAAA,UACjFrE,IADiF,GAC7D4E,KAD6D,CACjF5E,IADiF;EAAA,UAC3Ed,SAD2E,GAC7D0F,KAD6D,CAC3E1F,SAD2E;EAIzF;EACA;;EACA,UAAM+G,KAAc,GAAG,OAAOlH,IAAP,KAAgB,QAAvC,CANyF;;EAQzF,UAAMmH,aAAqB,GAAG7B,UAAU,GACnC4B,KAAK,GAAGjG,IAAI,GAAG,CAAV,GAAc,KAAKmG,mBAAL,CAAyBnG,IAAzB,EAA+Bd,SAA/B,EAA0C,IAA1C,CADgB,GAEnC+G,KAAK,GAAGjG,IAAI,GAAG,CAAV,GAAc,KAAKmG,mBAAL,CAAyBnG,IAAzB,EAA+Bd,SAA/B,EAA0C,KAA1C,CAFxB;EAIA,aAAO;EACH2G,QAAAA,KAAK,EAAEI,KAAK,GAAGlH,IAAH,GAAWsF,UAAU,GAAG,aAAH,GAAmB,cADjD;EAEH+B,QAAAA,QAAQ,EAAE,CAACH,KAFR;EAGHD,QAAAA,OAAO,EAAE;EAAA,iBAAMlB,KAAK,CAAC;EACjB/F,YAAAA,IAAI,EAAEmH;EADW,WAAD,CAAX;EAAA;EAHN,OAAP;EAOH;;;wCAEiBpB,OAAYF,OAA+B;EAAA;;EAAA,UACjD3E,MADiD,GACP2E,KADO,CACjD3E,MADiD;EAAA,UACzCJ,SADyC,GACP+E,KADO,CACzC/E,SADyC;EAAA,UAC9BoE,QAD8B,GACPW,KADO,CAC9BX,QAD8B;EAAA,UACpBP,QADoB,GACPkB,KADO,CACpBlB,QADoB;EAGzD,UAAM2C,YAAqB,GAAGxG,SAAS,IAAI,CAA3C,CAHyD;;EAMzD,UAAMyG,WAAsB,GAAID,YAAY,IAAIpG,MAAM,KAAK,CAA5B,GAC3B,CAAE,CAAF,CAD2B,IAEzB,CAFyB,4BAElBgE,QAAQ,GAAGA,QAAH,GAAc,EAFJ,IAEShE,MAFT,EAA/B;EAIA,UAAMsG,YAAuB,GAAIF,YAAY,IAAIpG,MAAM,KAAKJ,SAA5B,GAC5B,EAD4B,gCAEtB6D,QAAQ,GAAGA,QAAH,GAAc,EAFA,IAEK7D,SAFL,EAAhC;EAIA,UAAM2G,OAAkB,gCAAQF,WAAR,sBAAwBC,YAAxB,EAAxB;EACA,UAAME,iBAAyB,GAAGH,WAAW,CAAC7E,MAAZ,GAAqB,CAAvD;EAEA,aAAO;EACHoE,QAAAA,KAAK,EAAE,aADJ;EAEHE,QAAAA,QAAQ,EAAEM,YAFP;EAGHG,QAAAA,OAAO,EAAPA,OAHG;EAIHE,QAAAA,mBAAmB,EAAEzG,MAJlB;EAKHwG,QAAAA,iBAAiB,EAAjBA,iBALG;EAMHE,QAAAA,QAAQ,EAAE,yBAA4B;EAAA,cAAzB/D,MAAyB,SAAzBA,MAAyB;;EAClC,cAAMsD,aAAqB,GAAG,MAAI,CAACU,qBAAL,CAC1BhC,KAD0B,EAE1B4B,OAF0B,EAG1B,CAAEK,QAAQ,CAACjE,MAAM,CAACkE,KAAR,EAAe,EAAf,CAAV,EAA8BL,iBAA9B,CAH0B,CAA9B;;EAKA3B,UAAAA,KAAK,CAAC;EAAE/F,YAAAA,IAAI,EAAEmH;EAAR,WAAD,CAAL;EACH;EAbE,OAAP;EAeH;;;2CAEoBpB,OAAYH,QAAiC;EAAA,UACtD3F,SADsD,GAC1B2F,MAD0B,CACtD3F,SADsD;EAAA,UAC3CC,YAD2C,GAC1B0F,MAD0B,CAC3C1F,YAD2C;EAE9D,aAAO;EACH4G,QAAAA,KAAK,EAAE,iBADJ;EAEHE,QAAAA,QAAQ,EAAE/G,SAAS,CAACyC,MAAV,IAAoB,CAF3B;EAGH+E,QAAAA,OAAO,EAAExH,SAHN;EAIH0H,QAAAA,mBAAmB,EAAE1H,SAAS,CAACC,YAAD,CAJ3B;EAKHwH,QAAAA,iBAAiB,EAAExH,YALhB;EAMH0H,QAAAA,QAAQ,EAAE;EAAA,cAAG/D,MAAH,SAAGA,MAAH;EAAA,iBAA4BkC,KAAK,CAAC;EACxC/F,YAAAA,IAAI,EAAE,CADkC;EAExCE,YAAAA,YAAY,EAAE4H,QAAQ,CAACjE,MAAM,CAACkE,KAAR,EAAe,EAAf;EAFkB,WAAD,CAAjC;EAAA;EANP,OAAP;EAWH;;;8CAEuB3H,aAAqBwF,QAAiBE,UAAqB;EAAA;;EAC/E,aAAQ,UAAClG,SAAD,EAAuC;EAC3C,YAAMS,SAAkB,GAAG,MAAI,CAAC2H,SAAL,CAAepI,SAAf,EAA0BgG,MAA1B,CAA3B;;EACA,YAAMqC,QAAgB,GAAG,MAAI,CAACC,QAAL,CAAc9H,WAAd,EAA2BC,SAA3B,CAAzB;;EACA,YAAIyF,QAAJ,EAAcA,QAAQ,CAAC;EAAEzF,UAAAA,SAAS,EAATA,SAAF;EAAa4H,UAAAA,QAAQ,EAARA;EAAb,SAAD,CAAR;EACjB,OAJD;EAKH;;;4CAEqBpC,OAAesC,eAAkE;EAAA;EAAA,UAA/CC,OAA+C;EAAA,UAAtCC,SAAsC;;EAAA,UAC3FpH,IAD2F,GACvE4E,KADuE,CAC3F5E,IAD2F;EAAA,UACrFd,SADqF,GACvE0F,KADuE,CACrF1F,SADqF;EAEnG,UAAMH,IAAqB,GAAGmI,KAAK,CAACC,OAAD,CAAnC;EACA,UAAMjB,aAAqB,GAAG,OAAOnH,IAAP,KAAgB,QAAhB,GAC1BA,IAAI,GAAG,CADmB,GAE1B,KAAKoH,mBAAL,CAAyBnG,IAAzB,EAA+Bd,SAA/B,EAA0CiI,OAAO,GAAGC,SAApD,CAFJ;EAGA,aAAOlB,aAAP;EACH;;;;;;;;;;;;"}