// Generated by dts-bundle-generator v5.3.0

export interface IOption {
	page: number;
	increment: number[];
	incrementIdx: number;
	maxSpread: number;
}
export interface IState extends IPageCtx, IPageSlice, IRelPage, IRecordCtx, ISpreadCtx {
	perPage: number;
	totalPage: number;
}
export interface IPageCtx {
	curr: number;
	pageNo: number;
}
export interface IPageSlice {
	startIdx: number;
	endIdx: number;
}
export declare type IRelPage = {
	first: number;
	prev: number;
	next: number;
	last: number;
};
export interface IRecordCtx {
	totalRecord: number;
	startRecord: number;
	endRecord: number;
}
export interface ISpreadCtx {
	ltSpread: TSpreadCtx;
	rtSpread: TSpreadCtx;
	maxSpread: number;
}
export declare type TSpreadCtx = (number | "...")[];
export interface IPageRange {
	curr: number;
	last: number;
}
export interface IPageNavQuery {
	type: string;
	target?: number;
}
export interface IRelPageCtx extends TRelPageCtx {
}
export declare type TRelPageCtx = {
	[K in keyof IRelPage]: boolean;
};
export interface ICmpAttr {
	firstBtnAttr: ICmpBtnAttr;
	prevBtnAttr: ICmpBtnAttr;
	nextBtnAttr: ICmpBtnAttr;
	lastBtnAttr: ICmpBtnAttr;
	ltSpreadBtnsAttr: ICmpBtnAttr[];
	rtSpreadBtnsAttr: ICmpBtnAttr[];
	pageSelectAttr: ICmpSelectAttr;
	perPageSelectAttr: ICmpSelectAttr;
}
export interface ICmpAttrQuery {
	totalRecord: number;
	option: IOption;
	state: IState;
	callback: TFn;
}
export interface ICmpBtnAttr extends ICommonCmpAttr {
	isSpread?: boolean;
	onClick: TFn;
}
export interface ICmpSelectAttr extends ICommonCmpAttr {
	options: (string | number)[];
	selectedOptionValue: string | number;
	selectedOptionIdx: number;
	onSelect: TFn;
}
export interface ICommonCmpAttr {
	[k: string]: any;
	title: string;
	disabled?: boolean;
}
export declare type TPageList = (string | number)[];
export declare type TFn = (...args: any[]) => any;
declare class PgnHandle {
	/**
	 * Merge the updated option with existing option (either custom or default)
	 * e.g. existingOption = this.state.sortOption
	 */
	getOption(modOption: Partial<IOption>, existingOption?: IOption): IOption;
	getDefOption(): IOption;
	getState(totalRecord: number, pgnOption: Partial<IOption>): IState;
	getDefState(totalRecord: number, perPage: number): IState;
	getRecordCtx(totalRecord: number, startIdx: number, endIdx?: number): IRecordCtx;
	getNoPerPage(incrms: number[], incrmIdx: number, fallbackVal: number): number;
	parseNoPerPage(incrms: number[]): number[];
	getTotalPage(lsLen: number, perPage: number): number;
	getCurrPage(page: number, lastPage: number): IPageCtx;
	getRelPage(totalPage: number, currPage: number): IRelPage;
	getRelPageCtx(pageRange: IPageRange, relPage: IRelPage): IRelPageCtx;
	parseRelPage(relPage: IRelPage, relPageCtx: IRelPageCtx): IRelPage;
	getPageSliceIdx(totalRecord: number, perPage: number, page: number): IPageSlice;
	/**
	 * Get the page number for the left/right spread in relation to current page
	 * - When remain < maxSpread, show `maxSpread` no. of pages
	 * - When remain > maxSpread, show dots (either on left/right) + `maxSpread` no. of pages
	 * - when remain < 1, no spread is available
	 *
	 * @param maxSpread: max no. of pages for each side of the spread
	 */
	getSpreadCtx(currPageNo: number, totalPage: number, maxSpread?: number): ISpreadCtx;
	/**
	 * Forumla for calculating corresponding page index for left/right spread '...' based on the
	 * context of current page and the maxSpread (no. of pages between current and target page)
	 *
	 * e.g. maxSpread = 3
	 * ------------------------------------------------------------
	 * Current Page          | Spread/Target Page    | Spread Type
	 * No.      | Index      | No.      | Index      |
	 * ------------------------------------------------------------
	 * 1          0            4          3            Right Spread
	 * 10         9            6          5            Left Spread
	 */
	getPageIdxForSpread(currPageIdx: number, maxSpread: number, isLtSpread: boolean): number;
	canNavToPage({ curr, last }: IPageRange, { type, target }: IPageNavQuery): boolean;
	isGteZero(vals: any | any[]): boolean;
	/**
	 * Create Generic Attributes that can be passed/mapped to Attributes/Inputs/Props of Static HTML or Angular/React/Vue/etc Components
	 *
	 * - Usage Example for React:
	 * const callback = (modState => this.setState({...this.state, ...modState})).bind(this);
	 * createGenericCmpProps({option, state, data, callback});
	 */
	createGenericCmpAttr({ totalRecord, option, state, callback }: ICmpAttrQuery): ICmpAttr;
	getTextBtnAttr(onEvt: TFn, [title, pageIdx]: [string, number]): ICmpBtnAttr;
	getSpreadBtnAttr(onEvt: TFn, state: IState, [page, isLtSpread]: [any, boolean]): ICmpBtnAttr;
	getPageSelectAttr(onEvt: TFn, state: IState): ICmpSelectAttr;
	getPerPageSelectAttr(onEvt: TFn, option: IOption): ICmpSelectAttr;
	getGenericCmpEvtHandler(totalRecord: number, option: IOption, callback?: TFn): TFn;
	getTargetPageIdxByPos(state: IState, pages: TPageList, [currPos, activePos]: [number, number]): number;
}
export default PgnHandle;

export {};
